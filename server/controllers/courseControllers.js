// server/controllers/courseController.js
import Course from "../models/Course.js";
import Module from "../models/Module.js";
import Lesson from "../models/Lesson.js";
import {
  generateCourseOutlineWithAI,
  generateLessonContentWithAI,
} from "../services/aiService.js";

// --- NEW/MODIFIED generateCourse ---
const generateCourse = async (req, res) => {
  const { topic } = req.body;
  const creator = req.userId; // Auth0 user ID from middleware

  if (!creator) {
    return res.status(401).json({ message: "User not authenticated." });
  }

  if (!topic) {
    return res
      .status(400)
      .json({ message: "Topic is required to generate a course." });
  }

  try {
    // 1. Generate Course Outline (Modules and Lesson Titles) using AI
    console.log(`Generating course outline for topic: "${topic}"`);
    const courseOutline = await generateCourseOutlineWithAI(topic);
    console.log(
      "AI Generated Course Outline:",
      JSON.stringify(courseOutline, null, 2)
    );

    if (!courseOutline || !courseOutline.title || !courseOutline.modules) {
      throw new Error("AI did not return a valid course outline structure.");
    }

    // 2. Create and Save the Course Document
    const newCourse = new Course({
      title: courseOutline.title,
      description:
        courseOutline.description || "A comprehensive course generated by AI.",
      creator: creator,
      prompt: topic,
      tags: courseOutline.tags || [],
      modules: [], // Will be populated with module IDs after saving
    });
    await newCourse.save();
    console.log(`Course "${newCourse.title}" saved with ID: ${newCourse._id}`);

    const savedModuleIds = [];

    // 3. Iterate through AI-generated modules, create Module documents, and create placeholder Lessons
    for (const modData of courseOutline.modules) {
      if (!modData.moduleTitle || !modData.lessons) {
        console.warn("Skipping malformed module data:", modData);
        continue;
      }

      const newModule = new Module({
        title: modData.moduleTitle,
        course: newCourse._id,
        lessons: [], // Will be populated with lesson IDs after saving
      });
      await newModule.save();
      savedModuleIds.push(newModule._id);
      console.log(
        `Module "${newModule.title}" saved with ID: ${newModule._id}`
      );

      const savedLessonIds = [];
      // 4. Iterate through AI-generated lesson titles and save **placeholder** Lesson documents
      //    Lesson content will be generated only when requested
      for (const lesData of modData.lessons) {
        if (!lesData.lessonTitle) {
          console.warn("Skipping malformed lesson title data:", lesData);
          continue;
        }

        const newLesson = new Lesson({
          title: lesData.lessonTitle, // Just save the title
          content: [], // Empty array for now, indicates content is not generated
          isEnriched: false, // Mark as not yet enriched by AI for content
          module: newModule._id,
        });
        await newLesson.save();
        savedLessonIds.push(newLesson._id);
        console.log(
          `Placeholder Lesson "${newLesson.title}" saved with ID: ${newLesson._id}`
        );
      }
      // Update the Module with the IDs of its newly created placeholder lessons
      newModule.lessons = savedLessonIds;
      await newModule.save();
    }
    // Update the Course with the IDs of its newly created modules
    newCourse.modules = savedModuleIds;
    await newCourse.save();

    // After all saving, fetch the fully populated course outline to return to the frontend
    const fullCourseOutline = await Course.findById(newCourse._id).populate({
      path: "modules",
      populate: {
        path: "lessons", // Only titles will be present in lessons initially
      },
    });

    res.status(201).json(fullCourseOutline); // Send back the complete, populated course outline
  } catch (error) {
    console.error("Error generating and saving course outline:", error);
    res
      .status(500)
      .json({
        message: "Error generating or saving course outline",
        error: error.message,
      });
  }
};

// --- MODIFIED getLessonById for lazy generation ---
const getLessonById = async (req, res) => {
  try {
    const lessonId = req.params.id;
    let lesson = await Lesson.findById(lessonId);

    if (!lesson) {
      return res.status(404).json({ message: "Lesson not found." });
    }

    // If lesson content is empty or not enriched, generate it
    if (!lesson.isEnriched || !lesson.content || lesson.content.length === 0) {
      console.log(
        `Lesson content for "${lesson.title}" not found. Generating now...`
      );

      // Find parent module and course to provide context to AI
      const module = await Module.findById(lesson.module).populate("course");
      if (!module || !module.course) {
        throw new Error(
          "Parent module or course not found for lesson context."
        );
      }

      const courseTitle = module.course.title;
      const moduleTitle = module.title;
      const lessonTitle = lesson.title;

      const lessonContent = await generateLessonContentWithAI(
        courseTitle,
        moduleTitle,
        lessonTitle
      );
      console.log(
        `AI Generated Lesson Content for "${lesson.title}":`,
        JSON.stringify(lessonContent, null, 2)
      );

      if (!lessonContent || !lessonContent.content) {
        throw new Error(
          "AI did not return valid lesson content for this lesson."
        );
      }

      // Update the existing lesson document with the generated content
      lesson.content = lessonContent.content;
      lesson.objectives = lessonContent.objectives || []; // Add objectives field
      lesson.hinglishExplanation = lessonContent.hinglishExplanation;
      lesson.quiz = lessonContent.quiz;
      lesson.isEnriched = true; // Mark as enriched
      await lesson.save();
      console.log(`Lesson "${lesson.title}" content generated and saved.`);
    }
    res.status(200).json(lesson); // Return the lesson (either existing or newly generated)
  } catch (error) {
    console.error("Error fetching or generating lesson content:", error);
    res
      .status(500)
      .json({
        message: "Error fetching or generating lesson content",
        error: error.message,
      });
  }
};

const getCourseById = async (req, res) => {
  try {
    const course = await Course.findById(req.params.id).populate({
      path: "modules",
      populate: {
        path: "lessons",
      },
    });

    if (!course) {
      return res.status(404).json({ message: "Course not found" });
    }

    if (course.creator && req.userId && course.creator !== req.userId) {
      return res
        .status(403)
        .json({ message: "Access denied: You do not own this course." });
    }

    res.status(200).json(course);
  } catch (error) {
    console.error("Error fetching course (getCourseById):", error);
    res
      .status(500)
      .json({ message: "Error fetching course", error: error.message });
  }
};

const getUserCourses = async (req, res) => {
  const creator = req.userId; // User ID from Auth0 middleware

  if (!creator) {
    return res.status(401).json({ message: "User not authenticated." });
  }

  try {
    // Find all courses where the creator matches the logged-in user's ID
    // We'll populate modules to show a brief overview, but not lessons for performance
    const courses = await Course.find({ creator: creator })
      .populate({
        path: "modules",
        // You can choose to populate lessons here if you want to display lesson titles
        // on the "My Courses" page directly, but it might be too much data.
        // For now, we'll just get module titles.
        // populate: {
        //   path: 'lessons',
        //   select: 'title' // Only fetch lesson titles if you do populate
        // }
      })
      .sort({ createdAt: -1 }); // Sort by most recently created first

    res.status(200).json(courses);
  } catch (error) {
    console.error("Error fetching user courses:", error);
    res
      .status(500)
      .json({ message: "Error fetching user courses", error: error.message });
  }
};

export { generateCourse, getCourseById, getLessonById, getUserCourses };
